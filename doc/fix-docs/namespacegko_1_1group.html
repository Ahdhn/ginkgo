<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Ginkgo: gko::group Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_doc.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ginkgo
   &#160;<span id="projectnumber">develop 0.0.0</span>
   </div>
   <div id="projectbrief">Ginkgo is a numerical linear algebra library targeting manycore architectures.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="https://github.com/ginkgo-project/ginkgo/wiki/Tutorial:-Building-a-2D-Poisson-Solver"><span>Examples</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="https://ginkgo-project.github.io/"><span>Ginkgo</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegko.html">gko</a></li><li class="navelem"><a class="el" href="namespacegko_1_1group.html">group</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">gko::group Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Ginkgo uses cooperative groups introduced in CUDA 9.0 to handle communication among the threads.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1group_1_1grid__group.html">grid_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a limited implementation of the CUDA <a class="el" href="classgko_1_1group_1_1grid__group.html" title="This is a limited implementation of the CUDA grid_group that works even on devices that do not suppor...">grid_group</a> that works even on devices that do not support device-wide synchronization and without special kernel launch syntax.  <a href="classgko_1_1group_1_1grid__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgko_1_1group_1_1thread__block__tile.html">thread_block_tile</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0352eef231d9a4d45810ea2271a1f9cf"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0352eef231d9a4d45810ea2271a1f9cf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0352eef231d9a4d45810ea2271a1f9cf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko_1_1group.html#a0352eef231d9a4d45810ea2271a1f9cf">is_group</a> = detail::is_group_impl&lt; xstd::decay_t&lt; T &gt;&gt;</td></tr>
<tr class="memdesc:a0352eef231d9a4d45810ea2271a1f9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if T is a Group. <br /></td></tr>
<tr class="separator:a0352eef231d9a4d45810ea2271a1f9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba6bc20e1d851362b7a4c4f0bfdcdb6"><td class="memTemplParams" colspan="2"><a class="anchor" id="adba6bc20e1d851362b7a4c4f0bfdcdb6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adba6bc20e1d851362b7a4c4f0bfdcdb6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko_1_1group.html#adba6bc20e1d851362b7a4c4f0bfdcdb6">is_synchronizable_group</a> = detail::is_synchronizable_group_impl&lt; xstd::decay_t&lt; T &gt;&gt;</td></tr>
<tr class="memdesc:adba6bc20e1d851362b7a4c4f0bfdcdb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if T is a SynchronizableGroup. <br /></td></tr>
<tr class="separator:adba6bc20e1d851362b7a4c4f0bfdcdb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa140b74f349a1a4905ef466a142a4001"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa140b74f349a1a4905ef466a142a4001"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa140b74f349a1a4905ef466a142a4001"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko_1_1group.html#aa140b74f349a1a4905ef466a142a4001">is_communicator_group</a> = detail::is_communicator_group_impl&lt; xstd::decay_t&lt; T &gt;&gt;</td></tr>
<tr class="memdesc:aa140b74f349a1a4905ef466a142a4001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if T is a CommunicatorGroup. <br /></td></tr>
<tr class="separator:aa140b74f349a1a4905ef466a142a4001"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a93e10f0d0e1f51dc23b0aa5c68fa223c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93e10f0d0e1f51dc23b0aa5c68fa223c"></a>
__device__ <a class="el" href="classgko_1_1group_1_1grid__group.html">grid_group</a>&#160;</td><td class="memItemRight" valign="bottom"><b>this_grid</b> ()</td></tr>
<tr class="separator:a93e10f0d0e1f51dc23b0aa5c68fa223c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571ae4a8108d55474ef7ba99a2323079"><td class="memTemplParams" colspan="2"><a class="anchor" id="a571ae4a8108d55474ef7ba99a2323079"></a>
template&lt;typename Group &gt; </td></tr>
<tr class="memitem:a571ae4a8108d55474ef7ba99a2323079"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tiled_partition</b> (const Group &amp;g) -&gt; decltype(cooperative_groups::tiled_partition(g))</td></tr>
<tr class="separator:a571ae4a8108d55474ef7ba99a2323079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b1f86a4face469dddcd365b8188409"><td class="memTemplParams" colspan="2"><a class="anchor" id="a70b1f86a4face469dddcd365b8188409"></a>
template&lt;size_type Size, typename Group &gt; </td></tr>
<tr class="memitem:a70b1f86a4face469dddcd365b8188409"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ <a class="el" href="structgko_1_1group_1_1thread__block__tile.html">thread_block_tile</a>&lt; Size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tiled_partition</b> (const Group &amp;)</td></tr>
<tr class="separator:a70b1f86a4face469dddcd365b8188409"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Ginkgo uses cooperative groups introduced in CUDA 9.0 to handle communication among the threads. </p>
<p>However, CUDA's implementation of cooperative groups is still quite limited in functionality, and some parts are not supported on all hardware interesting for Ginkgo. For this reason, Ginkgo exposes only a part of the original functionality, and possibly extends it if it is required. Thus, developers should include and use this header and the <a class="el" href="namespacegko_1_1group.html" title="Ginkgo uses cooperative groups introduced in CUDA 9.0 to handle communication among the threads...">gko::group</a> namespace instead of the standard cooperative_groups.h header. The interface exposed by Ginkgo's implementation is equivalent to the standard interface, with some useful extensions.</p>
<p>A cooperative group (both from standard CUDA and from Ginkgo) is not a specific type, but a concept. That is, any type satisfying the interface imposed by the cooperative groups API is considered a cooperative group (a.k.a. "duck typing"). To maximize the generality of components than need cooperative groups, instead of creating the group manually, consider requesting one as an input parameter. Make sure its type is a template parameter to maximize the set of groups for which your algorithm can be invoked. To maximize the amount of contexts in which your algorithm can be called and avoid hidden requirements, do not depend on a specific setup of kernel launch parameters (i.e. grid dimensions and block dimensions). Instead, use the thread_rank() method of the group to distinguish between distinct threads of a group.</p>
<p>The original CUDA implementation does not provide ways to verify if a certain type represents a cooperative group. Ginkgo's implementation provides metafunctions which do that. Additionally, not all cooperative groups have equivalent functionality, so Ginkgo splits the cooperative group concept into three sub-concepts which describe what functionality is available. Here is a list of concepts and their interfaces:</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">concept Group {</div><div class="line">  <span class="keywordtype">unsigned</span> size() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">unsigned</span> thread_rank() <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line">concept SynchronizableGroup : Group {</div><div class="line">  <span class="keywordtype">void</span> sync();</div><div class="line">};</div><div class="line"></div><div class="line">concept CommunicatorGroup : SynchronizableGroup {</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">  T shfl(T var, <span class="keywordtype">int</span> srcLane);</div><div class="line">  T shfl_up(T var, <span class="keywordtype">unsigned</span> delta);</div><div class="line">  T shfl_down(T var, <span class="keywordtype">unsigned</span> delta);</div><div class="line">  T shfl_xor(T var, <span class="keywordtype">int</span> laneMask);</div><div class="line">  <span class="keywordtype">int</span> all(<span class="keywordtype">int</span> predicate);</div><div class="line">  <span class="keywordtype">int</span> any(<span class="keywordtype">int</span> predicate);</div><div class="line">  <span class="keywordtype">unsigned</span> ballot(<span class="keywordtype">int</span> predicate);</div><div class="line"></div><div class="line">  <span class="comment">// for compute capability &gt;= 7.0</span></div><div class="line">  <span class="keywordtype">unsigned</span> match_any(T value);</div><div class="line">  <span class="keywordtype">unsigned</span> match_all(T value);</div><div class="line">};</div></div><!-- fragment --><p>To check if a group T satisfies one of the concepts, one can use the metafunctions is_group&lt;T&gt;::value, is_synchronizable_group&lt;T&gt;::value and is_communicator_group&lt;T&gt;::value.</p>
<dl class="section note"><dt>Note</dt><dd>If you were referred to this file by the deprecation notices on Ginkgo's synchronization or shuffle API, please note that the current implementation of cooperative groups contains only a subset of functionalities provided by those APIs. If you need more functionality, please add the appropriate implementations to existing cooperative groups, or create new groups if the existing groups do not cover your use-case. For an example, see the enable_extended_shuffle mixin, which adds extended shuffles support to built-in CUDA cooperative groups. </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
