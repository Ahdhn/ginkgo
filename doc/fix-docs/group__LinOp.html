<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Ginkgo: Linear Operators</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_doc.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ginkgo
   &#160;<span id="projectnumber">develop 0.0.0</span>
   </div>
   <div id="projectbrief">Ginkgo is a numerical linear algebra library targeting manycore architectures.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="@ref Examples"><span>Examples</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="https://ginkgo-project.github.io/"><span>Ginkgo</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Linear Operators</div>  </div>
</div><!--header-->
<div class="contents">

<p>A module dedicated to the implementation and usage of the Linear operators in Ginkgo.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Linear Operators:</div>
<div class="dyncontent">
<center><table><tr><td><div class="center"><!-- SVG 0 -->
</div>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__mat__formats"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__formats.html">SpMV with Matrix formats</a></td></tr>
<tr class="memdesc:group__mat__formats"><td class="mdescLeft">&#160;</td><td class="mdescRight">A module dedicated to the implementation and usage of the various Matrix Formats in Ginkgo. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__precond"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__precond.html">Preconditioners</a></td></tr>
<tr class="memdesc:group__precond"><td class="mdescLeft">&#160;</td><td class="mdescRight">A module dedicated to the implementation and usage of the Preconditioners in Ginkgo. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__solvers"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__solvers.html">Solvers</a></td></tr>
<tr class="memdesc:group__solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">A module dedicated to the implementation and usage of the Solvers in Ginkgo. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Combination.html">gko::Combination&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1Combination.html" title="The Combination class can be used to construct a linear combination of multiple linear operators `c1 ...">Combination</a> class can be used to construct a linear combination of multiple linear operators `c1 * op1 + c2 * op2 + ...  <a href="classgko_1_1Combination.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Composition.html">gko::Composition&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1Composition.html" title="The Composition class can be used to compose linear operators op1, op2, ..., opn and obtain the opera...">Composition</a> class can be used to compose linear operators <code>op1, op2, ..., opn</code> and obtain the operator `op1 * op2 * ...  <a href="classgko_1_1Composition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1LinOp.html">gko::LinOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The linear operator (<a class="el" href="classgko_1_1LinOp.html" title="The linear operator (LinOp) is a base class for all linear algebra objects in Ginkgo. ">LinOp</a>) is a base class for all linear algebra objects in Ginkgo.  <a href="classgko_1_1LinOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1LinOpFactory.html">gko::LinOpFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1LinOpFactory.html" title="A LinOpFactory represents a higher order mapping which transforms one linear operator into another...">LinOpFactory</a> represents a higher order mapping which transforms one linear operator into another.  <a href="classgko_1_1LinOpFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1ReadableFromMatrixData.html">gko::ReadableFromMatrixData&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1LinOp.html" title="The linear operator (LinOp) is a base class for all linear algebra objects in Ginkgo. ">LinOp</a> implementing this interface can read its data from a <a class="el" href="structgko_1_1matrix__data.html" title="This structure is used as an intermediate data type to store a sparse matrix. ">matrix_data</a> structure.  <a href="classgko_1_1ReadableFromMatrixData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1WritableToMatrixData.html">gko::WritableToMatrixData&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1LinOp.html" title="The linear operator (LinOp) is a base class for all linear algebra objects in Ginkgo. ">LinOp</a> implementing this interface can write its data to a <a class="el" href="structgko_1_1matrix__data.html" title="This structure is used as an intermediate data type to store a sparse matrix. ">matrix_data</a> structure.  <a href="classgko_1_1WritableToMatrixData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Preconditionable.html">gko::Preconditionable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1LinOp.html" title="The linear operator (LinOp) is a base class for all linear algebra objects in Ginkgo. ">LinOp</a> implementing this interface can be preconditioned.  <a href="classgko_1_1Preconditionable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1EnableLinOp.html">gko::EnableLinOp&lt; ConcreteLinOp, PolymorphicBase &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1EnableLinOp.html" title="The EnableLinOp mixin can be used to provide sensible default implementations of the majority of the ...">EnableLinOp</a> mixin can be used to provide sensible default implementations of the majority of the <a class="el" href="classgko_1_1LinOp.html" title="The linear operator (LinOp) is a base class for all linear algebra objects in Ginkgo. ">LinOp</a> and <a class="el" href="classgko_1_1PolymorphicObject.html" title="A PolymorphicObject is the abstract base for all &quot;heavy&quot; objects in Ginkgo that behave polymorphicall...">PolymorphicObject</a> interface.  <a href="classgko_1_1EnableLinOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1Coo.html">gko::matrix::Coo&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">COO stores a matrix in the coordinate matrix format.  <a href="classgko_1_1matrix_1_1Coo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1Csr.html">gko::matrix::Csr&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSR is a matrix format which stores only the nonzero coefficients by compressing each row of the matrix (compressed sparse row format).  <a href="classgko_1_1matrix_1_1Csr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1Dense.html">gko::matrix::Dense&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1matrix_1_1Dense.html" title="Dense is a matrix format which explicitly stores all values of the matrix. ">Dense</a> is a matrix format which explicitly stores all values of the matrix.  <a href="classgko_1_1matrix_1_1Dense.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1Ell.html">gko::matrix::Ell&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ELL is a matrix format where stride with explicit zeros is used such that all rows have the same number of stored elements.  <a href="classgko_1_1matrix_1_1Ell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1Hybrid.html">gko::matrix::Hybrid&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">HYBRID is a matrix format which splits the matrix into ELLPACK and COO format.  <a href="classgko_1_1matrix_1_1Hybrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1Identity.html">gko::matrix::Identity&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a utility which efficiently implements the identity matrix (a linear operator which maps each vector to itself).  <a href="classgko_1_1matrix_1_1Identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1IdentityFactory.html">gko::matrix::IdentityFactory&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This factory is a utility which can be used to generate <a class="el" href="classgko_1_1matrix_1_1Identity.html" title="This class is a utility which efficiently implements the identity matrix (a linear operator which map...">Identity</a> operators.  <a href="classgko_1_1matrix_1_1IdentityFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1Sellp.html">gko::matrix::Sellp&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SELL-P is a matrix format similar to ELL format.  <a href="classgko_1_1matrix_1_1Sellp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgko_1_1preconditioner_1_1block__interleaved__storage__scheme.html">gko::preconditioner::block_interleaved_storage_scheme&lt; IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the parameters of the interleaved block storage scheme used by block-Jacobi blocks.  <a href="structgko_1_1preconditioner_1_1block__interleaved__storage__scheme.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1preconditioner_1_1Jacobi.html">gko::preconditioner::Jacobi&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A block-Jacobi preconditioner is a block-diagonal linear operator, obtained by inverting the diagonal blocks of the source operator.  <a href="classgko_1_1preconditioner_1_1Jacobi.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1solver_1_1Bicgstab.html">gko::solver::Bicgstab&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">BiCGSTAB or the Bi-Conjugate Gradient-Stabilized is a Krylov subspace solver.  <a href="classgko_1_1solver_1_1Bicgstab.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1solver_1_1Cg.html">gko::solver::Cg&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CG or the conjugate gradient method is an iterative type Krylov subspace method which is suitable for symmetric positive definite methods.  <a href="classgko_1_1solver_1_1Cg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1solver_1_1Cgs.html">gko::solver::Cgs&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGS or the conjugate gradient square method is an iterative type Krylov subspace method which is suitable for general systems.  <a href="classgko_1_1solver_1_1Cgs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1solver_1_1Fcg.html">gko::solver::Fcg&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">FCG or the flexible conjugate gradient method is an iterative type Krylov subspace method which is suitable for symmetric positive definite methods.  <a href="classgko_1_1solver_1_1Fcg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1solver_1_1Gmres.html">gko::solver::Gmres&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GMRES or the generalized minimal residual method is an iterative type Krylov subspace method which is suitable for nonsymmetric linear systems.  <a href="classgko_1_1solver_1_1Gmres.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga1fc8e9d8be0c9ad2d72bc1ddfc6d8358"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LinOp.html#ga1fc8e9d8be0c9ad2d72bc1ddfc6d8358">GKO_CREATE_FACTORY_PARAMETERS</a>(_parameters_name,  _factory_name)</td></tr>
<tr class="memdesc:ga1fc8e9d8be0c9ad2d72bc1ddfc6d8358"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Macro will generate a new type containing the parameters for the factory <code>_factory_name</code>.  <a href="#ga1fc8e9d8be0c9ad2d72bc1ddfc6d8358">More...</a><br /></td></tr>
<tr class="separator:ga1fc8e9d8be0c9ad2d72bc1ddfc6d8358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e0af90ec2414b768266f77cedffc309"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LinOp.html#ga8e0af90ec2414b768266f77cedffc309">GKO_ENABLE_LIN_OP_FACTORY</a>(_lin_op,  _parameters_name,  _factory_name)</td></tr>
<tr class="memdesc:ga8e0af90ec2414b768266f77cedffc309"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro will generate a default implementation of a LinOpFactory for the LinOp subclass it is defined in.  <a href="#ga8e0af90ec2414b768266f77cedffc309">More...</a><br /></td></tr>
<tr class="separator:ga8e0af90ec2414b768266f77cedffc309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga521f65604cc4cf427dcb2ecfa49b757c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LinOp.html#ga521f65604cc4cf427dcb2ecfa49b757c">GKO_ENABLE_BUILD_METHOD</a>(_factory_name)</td></tr>
<tr class="memdesc:ga521f65604cc4cf427dcb2ecfa49b757c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a build method for the factory, simplifying its construction by removing the repetitive typing of factory's name.  <a href="#ga521f65604cc4cf427dcb2ecfa49b757c">More...</a><br /></td></tr>
<tr class="separator:ga521f65604cc4cf427dcb2ecfa49b757c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa037309884bbd0562b897cee95dd91c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LinOp.html#gaa037309884bbd0562b897cee95dd91c8">GKO_FACTORY_PARAMETER</a>(_name, ...)</td></tr>
<tr class="memdesc:gaa037309884bbd0562b897cee95dd91c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a factory parameter in the factory parameters structure.  <a href="#gaa037309884bbd0562b897cee95dd91c8">More...</a><br /></td></tr>
<tr class="separator:gaa037309884bbd0562b897cee95dd91c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga24628d477cba68b31cea690572c51912"><td class="memTemplParams" colspan="2">template&lt;typename ConcreteFactory , typename ConcreteLinOp , typename ParametersType , typename PolymorphicBase  = LinOpFactory&gt; </td></tr>
<tr class="memitem:ga24628d477cba68b31cea690572c51912"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LinOp.html#ga24628d477cba68b31cea690572c51912">gko::EnableDefaultLinOpFactory</a> = EnableDefaultFactory&lt; ConcreteFactory, ConcreteLinOp, ParametersType, PolymorphicBase &gt;</td></tr>
<tr class="memdesc:ga24628d477cba68b31cea690572c51912"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an alias for the <a class="el" href="classgko_1_1EnableDefaultFactory.html" title="This mixin provides a default implementation of a concrete factory. ">EnableDefaultFactory</a> mixin, which correctly sets the template parameters to enable a subclass of <a class="el" href="classgko_1_1LinOpFactory.html" title="A LinOpFactory represents a higher order mapping which transforms one linear operator into another...">LinOpFactory</a>.  <a href="group__LinOp.html#ga24628d477cba68b31cea690572c51912">More...</a><br /></td></tr>
<tr class="separator:ga24628d477cba68b31cea690572c51912"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga06571a6dc284f0db2c47b38109ed3c83"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename... TArgs&gt; </td></tr>
<tr class="memitem:ga06571a6dc284f0db2c47b38109ed3c83"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Matrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LinOp.html#ga06571a6dc284f0db2c47b38109ed3c83">gko::initialize</a> (size_type stride, std::initializer_list&lt; typename Matrix::value_type &gt; vals, std::shared_ptr&lt; const Executor &gt; exec, TArgs &amp;&amp;...create_args)</td></tr>
<tr class="memdesc:ga06571a6dc284f0db2c47b38109ed3c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a column-vector.  <a href="group__LinOp.html#ga06571a6dc284f0db2c47b38109ed3c83">More...</a><br /></td></tr>
<tr class="separator:ga06571a6dc284f0db2c47b38109ed3c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12766c96efc0425fba250039af3eb781"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename... TArgs&gt; </td></tr>
<tr class="memitem:ga12766c96efc0425fba250039af3eb781"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Matrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LinOp.html#ga12766c96efc0425fba250039af3eb781">gko::initialize</a> (std::initializer_list&lt; typename Matrix::value_type &gt; vals, std::shared_ptr&lt; const Executor &gt; exec, TArgs &amp;&amp;...create_args)</td></tr>
<tr class="memdesc:ga12766c96efc0425fba250039af3eb781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a column-vector.  <a href="group__LinOp.html#ga12766c96efc0425fba250039af3eb781">More...</a><br /></td></tr>
<tr class="separator:ga12766c96efc0425fba250039af3eb781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cab71abbdd2761f46f3fde30c7e3720"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename... TArgs&gt; </td></tr>
<tr class="memitem:ga9cab71abbdd2761f46f3fde30c7e3720"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Matrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LinOp.html#ga9cab71abbdd2761f46f3fde30c7e3720">gko::initialize</a> (size_type stride, std::initializer_list&lt; std::initializer_list&lt; typename Matrix::value_type &gt;&gt; vals, std::shared_ptr&lt; const Executor &gt; exec, TArgs &amp;&amp;...create_args)</td></tr>
<tr class="memdesc:ga9cab71abbdd2761f46f3fde30c7e3720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a matrix.  <a href="group__LinOp.html#ga9cab71abbdd2761f46f3fde30c7e3720">More...</a><br /></td></tr>
<tr class="separator:ga9cab71abbdd2761f46f3fde30c7e3720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga691dd917874868551c840b8853e573bc"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename... TArgs&gt; </td></tr>
<tr class="memitem:ga691dd917874868551c840b8853e573bc"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Matrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LinOp.html#ga691dd917874868551c840b8853e573bc">gko::initialize</a> (std::initializer_list&lt; std::initializer_list&lt; typename Matrix::value_type &gt;&gt; vals, std::shared_ptr&lt; const Executor &gt; exec, TArgs &amp;&amp;...create_args)</td></tr>
<tr class="memdesc:ga691dd917874868551c840b8853e573bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a matrix.  <a href="group__LinOp.html#ga691dd917874868551c840b8853e573bc">More...</a><br /></td></tr>
<tr class="separator:ga691dd917874868551c840b8853e573bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A module dedicated to the implementation and usage of the Linear operators in Ginkgo. </p>
<p>Below we elaborate on one of the most important concepts of Ginkgo, the linear operator. The linear operator (LinOp) is a base class for all linear algebra objects in Ginkgo. The main benefit of having a single base class for the entire collection of linear algebra objects (as opposed to having separate hierarchies for matrices, solvers and preconditioners) is the generality it provides.</p>
<h1><a class="anchor" id="linop_1"></a>
Linear operator as a concept.</h1>
<p>A key observation for providing a unified interface for matrices, solvers, and preconditioners is that the most common operation performed on all of them can be expressed as an application of a linear operator to a vector:</p>
<ul>
<li>the sparse matrix-vector product with a matrix <img class="formulaInl" alt="$A$" src="form_0.png"/> is a linear operator application <img class="formulaInl" alt="$y = Ax$" src="form_1.png"/>;</li>
<li>the application of a preconditioner is a linear operator application <img class="formulaInl" alt="$y = M^{-1}x$" src="form_2.png"/>, where <img class="formulaInl" alt="$M$" src="form_3.png"/> is an approximation of the original system matrix <img class="formulaInl" alt="$A$" src="form_0.png"/> (thus a preconditioner represents an "approximate
    inverse" operator <img class="formulaInl" alt="$M^{-1}$" src="form_4.png"/>).</li>
<li>the system solve <img class="formulaInl" alt="$Ax = b$" src="form_5.png"/> can be viewed as linear operator application <img class="formulaInl" alt="$x = A^{-1}b$" src="form_6.png"/> (it goes without saying that the implementation of linear system solves does not follow this conceptual idea), so a linear system solver can be viewed as a representation of the operator <img class="formulaInl" alt="$A^{-1}$" src="form_7.png"/>.</li>
</ul>
<p>Consider the following example of the fixed-point iteration routine <img class="formulaInl" alt="$x_{k+1} = Lx_k + b$" src="form_8.png"/> :</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;matrix::Dense&lt;&gt;&gt; calculate_fixed_point(</div><div class="line">        <span class="keywordtype">int</span> iters, <span class="keyword">const</span> LinOp *L, <span class="keyword">const</span> matrix::Dense&lt;&gt; *x0</div><div class="line">        <span class="keyword">const</span> matrix::Dense&lt;&gt; *b)</div><div class="line">{</div><div class="line">    <span class="keyword">auto</span> x = gko::clone(x0);</div><div class="line">    <span class="keyword">auto</span> tmp = gko::clone(x0);</div><div class="line">    <span class="keyword">auto</span> one = Dense&lt;&gt;::create(L-&gt;get_executor(), {1.0,});</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; iters; ++i) {</div><div class="line">        L-&gt;apply(gko::lend(tmp), gko::lend(x));</div><div class="line">        x-&gt;add_scaled(gko::lend(one), gko::lend(b));</div><div class="line">        tmp-&gt;copy_from(gko::lend(x));</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> x;</div><div class="line">}</div></div><!-- fragment --><p>Here, if <img class="formulaInl" alt="$L$" src="form_9.png"/> is a matrix, LinOp::apply() refers to the matrix vector product, and <code>L-&gt;apply(a, b)</code> computes <img class="formulaInl" alt="$b = L \cdot a$" src="form_10.png"/>. <code>x-&gt;add_scaled(one.get(), b.get())</code> is the <code>axpy</code> vector update <img class="formulaInl" alt="$x:=x+b$" src="form_11.png"/>.</p>
<p>The interesting part of this example is the apply() routine at line 4 of the function body. This routine is made a part of the LinOp base class and hence the fixed-point iteration routine can calculate a fixed point not only for matrices, but for any type of linear operator.</p>
<h1><a class="anchor" id="linop_2"></a>
How does it work ?.</h1>
<p>And the answer is runtime polymorphism. Each of the classes that derive from the LinOp class implement an apply method which they override from the base LinOp class. All the various subclasses provide a common interface and hence the library users are exposed to a smaller set of routines. For example, a matrix-vector product, a preconditioner application, or even a system solve are just different terms given to the operation of applying a certain linear operator to a vector. As such, Ginkgo uses the same routine name, LinOp::apply() for each of these operations, where the actual operation performed depends on the type of linear operator involved in the operation.</p>
<h1><a class="anchor" id="linop_3"></a>
Advantages of this approach and usage</h1>
<p>A common interface often allows for writing more generic code. If a user's routine requires only operations provided by the LinOp interface, the same code can be used for any kind of linear operators, independent of whether these are matrices, solvers or preconditioners. This feature is also extensively used in Ginkgo itself. For example, a preconditioner used inside a Krylov solver is a LinOp. This allows the user to supply a wide variety of preconditioners: either the ones which were designed to be used in this scenario (like ILU or block-Jacobi), a user-supplied matrix which is known to be a good preconditioner for the specific problem, or even another solver (e.g., if constructing a flexible GMRES solver).</p>
<p>For example, a matrix free implementation would require the user to provide an apply implementation and instead of passing the generated matrix to the solver, they would have to provide their apply implementation for all the executors needed and not other code needs to be changed. See custom_matrix_format example for more details. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga1fc8e9d8be0c9ad2d72bc1ddfc6d8358"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GKO_CREATE_FACTORY_PARAMETERS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_parameters_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_factory_name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">public</span>:                                                                \</div><div class="line">    class _factory_name;                                               \</div><div class="line">    struct _parameters_name##_type                                     \</div><div class="line">        : <a class="code" href="structgko_1_1enable__parameters__type.html">::gko::enable_parameters_type</a>&lt;_parameters_name##_type,       \</div><div class="line">                                        _factory_name&gt;</div><div class="ttc" id="structgko_1_1enable__parameters__type_html"><div class="ttname"><a href="structgko_1_1enable__parameters__type.html">gko::enable_parameters_type</a></div><div class="ttdoc">The enable_parameters_type mixin is used to create a base implementation of the factory parameters st...</div><div class="ttdef"><b>Definition:</b> abstract_factory.hpp:265</div></div>
</div><!-- fragment -->
<p>This Macro will generate a new type containing the parameters for the factory <code>_factory_name</code>. </p>
<p>For more details, see <a class="el" href="group__LinOp.html#ga8e0af90ec2414b768266f77cedffc309" title="This macro will generate a default implementation of a LinOpFactory for the LinOp subclass it is defi...">GKO_ENABLE_LIN_OP_FACTORY()</a>. It is required to use this macro <b>before</b> calling the macro <a class="el" href="group__LinOp.html#ga8e0af90ec2414b768266f77cedffc309" title="This macro will generate a default implementation of a LinOpFactory for the LinOp subclass it is defi...">GKO_ENABLE_LIN_OP_FACTORY()</a>. It is also required to use the same names for all parameters between both macros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_parameters_name</td><td>name of the parameters member in the class </td></tr>
    <tr><td class="paramname">_factory_name</td><td>name of the generated factory type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga521f65604cc4cf427dcb2ecfa49b757c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GKO_ENABLE_BUILD_METHOD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_factory_name</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">auto</span> build()-&gt;decltype(Factory::create())                         \</div><div class="line">    {                                                                        \</div><div class="line">        return Factory::create();                                            \</div><div class="line">    }                                                                        \</div><div class="line">    static_assert(<span class="keyword">true</span>,                                                      \</div><div class="line">                  <span class="stringliteral">&quot;This assert is used to counter the false positive extra &quot;</span> \</div><div class="line">                  <span class="stringliteral">&quot;semi-colon warnings&quot;</span>)</div></div><!-- fragment -->
<p>Defines a build method for the factory, simplifying its construction by removing the repetitive typing of factory's name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_factory_name</td><td>the factory for which to define the method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8e0af90ec2414b768266f77cedffc309"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GKO_ENABLE_LIN_OP_FACTORY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_lin_op, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_parameters_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_factory_name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">public</span>:                                                                      \</div><div class="line">    const _parameters_name##_type &amp;get_##_parameters_name() const            \</div><div class="line">    {                                                                        \</div><div class="line">        return _parameters_name##_;                                          \</div><div class="line">    }                                                                        \</div><div class="line">                                                                             \</div><div class="line">    class _factory_name                                                      \</div><div class="line">        : <a class="code" href="group__LinOp.html#ga24628d477cba68b31cea690572c51912">public ::gko::EnableDefaultLinOpFactory</a>&lt;_factory_name, _lin_op,    \</div><div class="line">                                                  _parameters_name##_type&gt; { \</div><div class="line">        friend class ::gko::EnablePolymorphicObject&lt;_factory_name,           \</div><div class="line">                                                    <a class="code" href="classgko_1_1LinOpFactory.html">::gko::LinOpFactory</a>&gt;;    \</div><div class="line">        friend class ::gko::enable_parameters_type&lt;_parameters_name##_type,  \</div><div class="line">                                                   _factory_name&gt;;           <a class="code" href="group__LinOp.html#ga24628d477cba68b31cea690572c51912">\</a></div><div class="line"><a class="code" href="group__LinOp.html#ga24628d477cba68b31cea690572c51912">        using ::gko::EnableDefaultLinOpFactory</a>&lt;                              \</div><div class="line">            _factory_name, _lin_op,                                          \</div><div class="line">            _parameters_name##_type&gt;<a class="code" href="group__LinOp.html#ga24628d477cba68b31cea690572c51912">::EnableDefaultLinOpFactory</a>;             \</div><div class="line">    };                                                                       <a class="code" href="group__LinOp.html#ga24628d477cba68b31cea690572c51912">\</a></div><div class="line"><a class="code" href="group__LinOp.html#ga24628d477cba68b31cea690572c51912">    friend ::gko::EnableDefaultLinOpFactory</a>&lt;_factory_name, _lin_op,          \</div><div class="line">                                            _parameters_name##_type&gt;;        \</div><div class="line">                                                                             \</div><div class="line">                                                                             \</div><div class="line">private:                                                                     \</div><div class="line">    _parameters_name##_type _parameters_name##_;                             \</div><div class="line">                                                                             \</div><div class="line">public:                                                                      \</div><div class="line">    static_assert(<span class="keyword">true</span>,                                                      \</div><div class="line">                  <span class="stringliteral">&quot;This assert is used to counter the false positive extra &quot;</span> \</div><div class="line">                  <span class="stringliteral">&quot;semi-colon warnings&quot;</span>)</div><div class="ttc" id="classgko_1_1LinOpFactory_html"><div class="ttname"><a href="classgko_1_1LinOpFactory.html">gko::LinOpFactory</a></div><div class="ttdoc">A LinOpFactory represents a higher order mapping which transforms one linear operator into another...</div><div class="ttdef"><b>Definition:</b> lin_op.hpp:353</div></div>
<div class="ttc" id="group__LinOp_html_ga24628d477cba68b31cea690572c51912"><div class="ttname"><a href="group__LinOp.html#ga24628d477cba68b31cea690572c51912">gko::EnableDefaultLinOpFactory</a></div><div class="ttdeci">EnableDefaultFactory&lt; ConcreteFactory, ConcreteLinOp, ParametersType, PolymorphicBase &gt; EnableDefaultLinOpFactory</div><div class="ttdoc">This is an alias for the EnableDefaultFactory mixin, which correctly sets the template parameters to ...</div><div class="ttdef"><b>Definition:</b> lin_op.hpp:593</div></div>
</div><!-- fragment -->
<p>This macro will generate a default implementation of a LinOpFactory for the LinOp subclass it is defined in. </p>
<p>It is required to first call the macro <a class="el" href="group__LinOp.html#ga1fc8e9d8be0c9ad2d72bc1ddfc6d8358" title="This Macro will generate a new type containing the parameters for the factory _factory_name. ">GKO_CREATE_FACTORY_PARAMETERS()</a> before this one in order to instantiate the parameters type first.</p>
<p>The list of parameters for the factory should be defined in a code block after the macro definition, and should contain a list of GKO_FACTORY_PARAMETER declarations. The class should provide a constructor with signature _lin_op(const _factory_name *, std::shared_ptr&lt;const LinOp&gt;) which the factory will use a callback to construct the object.</p>
<p>A minimal example of a linear operator is the following:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;struct MyLinOp : public EnableLinOp&lt;MyLinOp&gt; {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    GKO_ENABLE_LIN_OP_FACTORY(MyLinOp, my_parameters, Factory) {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;        // a factory parameter named &quot;my_value&quot;, of type int and default</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;        // value of 5</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;        int GKO_FACTORY_PARAMETER(my_value, 5);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    };</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    // constructor needed by EnableLinOp</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    explicit MyLinOp(std::shared_ptr&lt;const Executor&gt; exec) {</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;        : EnableLinOp&lt;MyLinOp&gt;(exec) {}</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    // constructor needed by the factory</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    explicit MyLinOp(const Factory *factory,</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;                     std::shared_ptr&lt;const LinOp&gt; matrix)</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        : EnableLinOp&lt;MyLinOp&gt;(factory-&gt;get_executor()), matrix-&gt;get_size()),</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;          // store factory&#39;s parameters locally</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;          my_parameters_{factory-&gt;get_parameters()},</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    {</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;         int value = my_parameters_.my_value;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;         // do something with value</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    }</div></div><!-- fragment --><p>MyLinOp can then be created as follows:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;auto exec = gko::ReferenceExecutor::create();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;// create a factory with default `my_value` parameter</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;auto fact = MyLinOp::build().on(exec);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;// create a operator using the factory:</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;auto my_op = fact-&gt;generate(gko::matrix::Identity::create(exec, 2));</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;std::cout &lt;&lt; my_op-&gt;get_my_parameters().my_value;  // prints 5</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;// create a factory with custom `my_value` parameter</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;auto fact = MyLinOp::build().with_my_value(0).on(exec);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;// create a operator using the factory:</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;auto my_op = fact-&gt;generate(gko::matrix::Identity::create(exec, 2));</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;std::cout &lt;&lt; my_op-&gt;get_my_parameters().my_value;  // prints 0</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is possible to combine both the #GKO_CREATE_FACTORY_PARAMETER() macro with this one in a unique macro for class <b>templates</b> (not with regular classes). Splitting this into two distinct macros allows to use them in all contexts. See <a href="https://stackoverflow.com/q/50202718/9385966">https://stackoverflow.com/q/50202718/9385966</a> for more details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_lin_op</td><td>concrete operator for which the factory is to be created [CRTP parameter] </td></tr>
    <tr><td class="paramname">_parameters_name</td><td>name of the parameters member in the class (its type is <code>&lt;_parameters_name&gt;_type</code>, the protected member's name is <code>&lt;_parameters_name&gt;_</code>, and the public getter's name is <code>get_&lt;_parameters_name&gt;()</code>) </td></tr>
    <tr><td class="paramname">_factory_name</td><td>name of the generated factory type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa037309884bbd0562b897cee95dd91c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GKO_FACTORY_PARAMETER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">mutable</span> _name{__VA_ARGS__};                                              \</div><div class="line">                                                                             \</div><div class="line">    template &lt;<span class="keyword">typename</span>... Args&gt;                                              \</div><div class="line">    auto with_##_name(Args &amp;&amp;... _value)                                     \</div><div class="line">        const-&gt;const ::gko::xstd::decay_t&lt;decltype(*<span class="keyword">this</span>)&gt; &amp;                 \</div><div class="line">    {                                                                        \</div><div class="line">        using type = decltype(this-&gt;_name);                                  \</div><div class="line">        this-&gt;_name = type{std::forward&lt;Args&gt;(_value)...};                   \</div><div class="line">        return *<span class="keyword">this</span>;                                                        \</div><div class="line">    }                                                                        \</div><div class="line">    static_assert(<span class="keyword">true</span>,                                                      \</div><div class="line">                  <span class="stringliteral">&quot;This assert is used to counter the false positive extra &quot;</span> \</div><div class="line">                  <span class="stringliteral">&quot;semi-colon warnings&quot;</span>)</div></div><!-- fragment -->
<p>Creates a factory parameter in the factory parameters structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_name</td><td>name of the parameter </td></tr>
    <tr><td class="paramname">&lt;strong&gt;VA_ARGS&lt;/strong&gt;</td><td>default value of the parameter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__LinOp.html#ga8e0af90ec2414b768266f77cedffc309" title="This macro will generate a default implementation of a LinOpFactory for the LinOp subclass it is defi...">GKO_ENABLE_LIN_OP_FACTORY</a> for more details, and usage example </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga24628d477cba68b31cea690572c51912"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteFactory , typename ConcreteLinOp , typename ParametersType , typename PolymorphicBase  = LinOpFactory&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__LinOp.html#ga24628d477cba68b31cea690572c51912">gko::EnableDefaultLinOpFactory</a> = typedef EnableDefaultFactory&lt;ConcreteFactory, ConcreteLinOp, ParametersType, PolymorphicBase&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an alias for the <a class="el" href="classgko_1_1EnableDefaultFactory.html" title="This mixin provides a default implementation of a concrete factory. ">EnableDefaultFactory</a> mixin, which correctly sets the template parameters to enable a subclass of <a class="el" href="classgko_1_1LinOpFactory.html" title="A LinOpFactory represents a higher order mapping which transforms one linear operator into another...">LinOpFactory</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ConcreteFactory</td><td>the concrete factory which is being implemented [CRTP parmeter] </td></tr>
    <tr><td class="paramname">ConcreteLinOp</td><td>the concrete <a class="el" href="classgko_1_1LinOp.html" title="The linear operator (LinOp) is a base class for all linear algebra objects in Ginkgo. ">LinOp</a> type which this factory produces, needs to have a constructor which takes a const ConcreteFactory *, and an std::shared_ptr&lt;const LinOp&gt; as parameters. </td></tr>
    <tr><td class="paramname">ParametersType</td><td>a subclass of <a class="el" href="structgko_1_1enable__parameters__type.html" title="The enable_parameters_type mixin is used to create a base implementation of the factory parameters st...">enable_parameters_type</a> template which defines all of the parameters of the factory </td></tr>
    <tr><td class="paramname">PolymorphicBase</td><td>parent of ConcreteFactory in the polymorphic hierarchy, has to be a subclass of <a class="el" href="classgko_1_1LinOpFactory.html" title="A LinOpFactory represents a higher order mapping which transforms one linear operator into another...">LinOpFactory</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga06571a6dc284f0db2c47b38109ed3c83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename... TArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Matrix&gt; gko::initialize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; typename Matrix::value_type &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>create_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and initializes a column-vector. </p>
<p>This function first creates a temporary Dense matrix, fills it with passed in values, and then converts the matrix to the requested type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>matrix type to initialize (Dense has to implement the ConvertibleTo&lt;Matrix&gt; interface) </td></tr>
    <tr><td class="paramname">TArgs</td><td>argument types for Matrix::create method (not including the implied <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor. ">Executor</a> as the first argument)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stride</td><td>row stride for the temporary Dense matrix </td></tr>
    <tr><td class="paramname">vals</td><td>values used to initialize the vector </td></tr>
    <tr><td class="paramname">exec</td><td><a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor. ">Executor</a> associated to the vector </td></tr>
    <tr><td class="paramname">create_args</td><td>additional arguments passed to Matrix::create, not including the <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor. ">Executor</a>, which is passed as the first argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga12766c96efc0425fba250039af3eb781"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename... TArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Matrix&gt; gko::initialize </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; typename Matrix::value_type &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>create_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and initializes a column-vector. </p>
<p>This function first creates a temporary Dense matrix, fills it with passed in values, and then converts the matrix to the requested type. The stride of the intermediate Dense matrix is set to 1.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>matrix type to initialize (Dense has to implement the ConvertibleTo&lt;Matrix&gt; interface) </td></tr>
    <tr><td class="paramname">TArgs</td><td>argument types for Matrix::create method (not including the implied <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor. ">Executor</a> as the first argument)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vals</td><td>values used to initialize the vector </td></tr>
    <tr><td class="paramname">exec</td><td><a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor. ">Executor</a> associated to the vector </td></tr>
    <tr><td class="paramname">create_args</td><td>additional arguments passed to Matrix::create, not including the <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor. ">Executor</a>, which is passed as the first argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9cab71abbdd2761f46f3fde30c7e3720"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename... TArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Matrix&gt; gko::initialize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; std::initializer_list&lt; typename Matrix::value_type &gt;&gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>create_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and initializes a matrix. </p>
<p>This function first creates a temporary Dense matrix, fills it with passed in values, and then converts the matrix to the requested type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>matrix type to initialize (Dense has to implement the ConvertibleTo&lt;Matrix&gt; interface) </td></tr>
    <tr><td class="paramname">TArgs</td><td>argument types for Matrix::create method (not including the implied <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor. ">Executor</a> as the first argument)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stride</td><td>row stride for the temporary Dense matrix </td></tr>
    <tr><td class="paramname">vals</td><td>values used to initialize the matrix </td></tr>
    <tr><td class="paramname">exec</td><td><a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor. ">Executor</a> associated to the matrix </td></tr>
    <tr><td class="paramname">create_args</td><td>additional arguments passed to Matrix::create, not including the <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor. ">Executor</a>, which is passed as the first argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga691dd917874868551c840b8853e573bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename... TArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Matrix&gt; gko::initialize </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::initializer_list&lt; typename Matrix::value_type &gt;&gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>create_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and initializes a matrix. </p>
<p>This function first creates a temporary Dense matrix, fills it with passed in values, and then converts the matrix to the requested type. The stride of the intermediate Dense matrix is set to the number of columns of the initializer list.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>matrix type to initialize (Dense has to implement the ConvertibleTo&lt;Matrix&gt; interface) </td></tr>
    <tr><td class="paramname">TArgs</td><td>argument types for Matrix::create method (not including the implied <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor. ">Executor</a> as the first argument)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vals</td><td>values used to initialize the matrix </td></tr>
    <tr><td class="paramname">exec</td><td><a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor. ">Executor</a> associated to the matrix </td></tr>
    <tr><td class="paramname">create_args</td><td>additional arguments passed to Matrix::create, not including the <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor. ">Executor</a>, which is passed as the first argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
